"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ramda_1 = require("ramda");
const IOClients_1 = require("../clients/IOClients");
const MetricsAccumulator_1 = require("../metrics/MetricsAccumulator");
const unhandled_1 = require("../utils/unhandled");
const graphql_1 = require("./graphql");
const http_1 = require("./http");
const defaultClients = {
    options: {
        messages: {
            concurrency: 15,
            retries: 2,
            timeout: 1000,
        },
    },
};
class Runtime {
    constructor(service, 
    // tslint:disable-next-line
    descriptor) {
        this.__is_service = true; // tslint:disable-line
        const { config } = service;
        const clients = {
            implementation: config.clients && config.clients.implementation || IOClients_1.IOClients,
            options: Object.assign({}, defaultClients.options, config.clients ? config.clients.options : null),
        };
        const Clients = clients.implementation;
        this.routes = config.routes
            ? ramda_1.map(http_1.createHttpRoute(Clients, clients.options), config.routes)
            : {};
        if (config.graphql) {
            let graphqlRoute = graphql_1.GRAPHQL_ROUTE;
            if (descriptor.routes && descriptor.routes[graphql_1.GRAPHQL_ROUTE_LEGACY]) {
                console.warn('Using legacy graphql route id', graphql_1.GRAPHQL_ROUTE_LEGACY);
                graphqlRoute = graphql_1.GRAPHQL_ROUTE_LEGACY;
            }
            this.routes[graphqlRoute] = graphql_1.createGraphQLRoute(config.graphql, Clients, clients.options);
        }
        this.events = config.events;
        this.statusTrack = global.metrics.statusTrack;
        unhandled_1.addProcessListeners();
    }
}
exports.Runtime = Runtime;
if (!global.metrics) {
    global.metrics = new MetricsAccumulator_1.MetricsAccumulator();
}
