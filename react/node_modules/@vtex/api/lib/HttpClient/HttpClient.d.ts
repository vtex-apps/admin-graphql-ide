/// <reference types="node" />
import { AxiosResponse } from 'axios';
import { IncomingMessage } from 'http';
import { Middleware } from 'koa-compose';
import { CacheLayer } from '../caches/CacheLayer';
import { MetricsAccumulator } from '../metrics/MetricsAccumulator';
import { Cached } from './middlewares/cache';
import { AuthType, IOResponse, MiddlewareContext, Recorder, RequestConfig } from './typings';
interface ClientOptions {
    authType?: AuthType;
    authToken?: string;
    userAgent: string;
    baseURL?: string;
    timeout?: number;
    recorder?: Recorder;
    metrics?: MetricsAccumulator;
    memoryCache?: CacheLayer<string, Cached>;
    diskCache?: CacheLayer<string, Cached>;
    segmentToken?: string;
    sessionToken?: string;
    retries?: number;
    concurrency?: number;
    headers?: Record<string, string>;
    params?: Record<string, string>;
    middlewares?: Array<Middleware<MiddlewareContext>>;
    operationId: string;
    verbose?: boolean;
}
export declare class HttpClient {
    static forWorkspace: (service: string, context: import("..").IOContext, opts: import("./typings").InstanceOptions) => HttpClient;
    static forRoot: (service: string, context: import("..").IOContext, opts: import("./typings").InstanceOptions) => HttpClient;
    static forExternal: (baseURL: string, context: import("..").IOContext, opts: import("./typings").InstanceOptions) => HttpClient;
    private runMiddlewares;
    constructor(opts: ClientOptions);
    get: <T = any>(url: string, config?: RequestConfig) => Promise<T>;
    getRaw: <T = any>(url: string, config?: RequestConfig) => Promise<IOResponse<T>>;
    getBuffer: (url: string, config?: RequestConfig) => Promise<{
        data: Buffer;
        headers: any;
    }>;
    getStream: (url: string, config?: RequestConfig) => Promise<IncomingMessage>;
    put: <T = void>(url: string, data?: any, config?: RequestConfig) => Promise<T>;
    post: <T = void>(url: string, data?: any, config?: RequestConfig) => Promise<T>;
    postRaw: <T = void>(url: string, data?: any, config?: RequestConfig) => Promise<IOResponse<T>>;
    patch: <T = void>(url: string, data?: any, config?: RequestConfig) => Promise<T>;
    delete: <T = void>(url: string, config?: RequestConfig | undefined) => Promise<IOResponse<T>>;
    protected request: (config: RequestConfig) => Promise<AxiosResponse<any>>;
}
export {};
