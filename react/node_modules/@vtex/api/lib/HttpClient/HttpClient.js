"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const koa_compose_1 = __importDefault(require("koa-compose"));
const p_limit_1 = __importDefault(require("p-limit"));
const factories_1 = require("./factories");
const cache_1 = require("./middlewares/cache");
const inflight_1 = require("./middlewares/inflight");
const memoization_1 = require("./middlewares/memoization");
const metrics_1 = require("./middlewares/metrics");
const notFound_1 = require("./middlewares/notFound");
const recorder_1 = require("./middlewares/recorder");
const request_1 = require("./middlewares/request");
const DEFAULT_TIMEOUT_MS = 1000;
const noTransforms = [(data) => data];
class HttpClient {
    constructor(opts) {
        this.get = (url, config = {}) => {
            const cacheableConfig = Object.assign({ memoizable: true, cacheable: cache_1.CacheType.Memory }, config, { url });
            return this.request(cacheableConfig).then(response => response.data);
        };
        this.getRaw = (url, config = {}) => {
            const cacheableConfig = Object.assign({ memoizable: true, cacheable: cache_1.CacheType.Memory }, config, { url });
            return this.request(cacheableConfig);
        };
        this.getBuffer = (url, config = {}) => {
            const bufferConfig = Object.assign({ cacheable: cache_1.CacheType.Disk }, config, { url, responseType: 'arraybuffer', transformResponse: noTransforms });
            return this.request(bufferConfig);
        };
        this.getStream = (url, config = {}) => {
            const streamConfig = Object.assign({}, config, { url, responseType: 'stream', transformResponse: noTransforms });
            return this.request(streamConfig).then(response => response.data);
        };
        this.put = (url, data, config = {}) => {
            const putConfig = Object.assign({}, config, { url, data, method: 'put' });
            return this.request(putConfig).then(response => response.data);
        };
        this.post = (url, data, config = {}) => {
            const postConfig = Object.assign({}, config, { url, data, method: 'post' });
            return this.request(postConfig).then(response => response.data);
        };
        this.postRaw = (url, data, config = {}) => {
            const postConfig = Object.assign({}, config, { url, data, method: 'post' });
            return this.request(postConfig);
        };
        this.patch = (url, data, config = {}) => {
            const patchConfig = Object.assign({}, config, { url, data, method: 'patch' });
            return this.request(patchConfig).then(response => response.data);
        };
        this.delete = (url, config) => {
            const deleteConfig = Object.assign({}, config, { url, method: 'delete' });
            return this.request(deleteConfig);
        };
        this.request = async (config) => {
            const context = { config };
            await this.runMiddlewares(context);
            return context.response;
        };
        const { baseURL, authToken, authType, memoryCache, diskCache, metrics, recorder, userAgent, timeout = DEFAULT_TIMEOUT_MS, segmentToken, retries, concurrency, headers: defaultHeaders, params, operationId, verbose } = opts;
        const limit = concurrency && concurrency > 0 && p_limit_1.default(concurrency) || undefined;
        const headers = Object.assign({}, defaultHeaders, { 'Accept-Encoding': 'gzip', 'User-Agent': userAgent }, operationId ? { 'x-vtex-operation-id': operationId } : null, segmentToken ? { 'x-vtex-segment': segmentToken } : null);
        if (authType && authToken) {
            headers['Authorization'] = `${authType} ${authToken}`; // tslint:disable-line
        }
        const memoizedCache = new Map();
        this.runMiddlewares = koa_compose_1.default([...opts.middlewares || [],
            request_1.defaultsMiddleware(baseURL, headers, params, timeout, retries, verbose),
            ...metrics ? [metrics_1.metricsMiddleware(metrics)] : [],
            memoization_1.memoizationMiddleware({ memoizedCache }),
            ...recorder ? [recorder_1.recorderMiddleware(recorder)] : [],
            inflight_1.singleFlightMiddleware,
            notFound_1.acceptNotFoundMiddleware,
            ...memoryCache ? [cache_1.cacheMiddleware({ type: cache_1.CacheType.Memory, storage: memoryCache, segmentToken: segmentToken || '' })] : [],
            ...diskCache ? [cache_1.cacheMiddleware({ type: cache_1.CacheType.Disk, storage: diskCache, segmentToken: segmentToken || '' })] : [],
            notFound_1.notFoundFallbackMiddleware,
            request_1.requestMiddleware(limit),
        ]);
    }
}
HttpClient.forWorkspace = factories_1.forWorkspace;
HttpClient.forRoot = factories_1.forRoot;
HttpClient.forExternal = factories_1.forExternal;
exports.HttpClient = HttpClient;
