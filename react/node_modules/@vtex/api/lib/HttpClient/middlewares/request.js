"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const axios_1 = __importDefault(require("axios"));
const axios_retry_1 = __importStar(require("axios-retry"));
const http_1 = require("http");
const qs_1 = require("qs");
const ramda_1 = require("ramda");
const retry_1 = require("../../utils/retry");
const time_1 = require("../../utils/time");
const httpAgent = new http_1.Agent({
    keepAlive: true,
    maxFreeSockets: 50,
});
const http = axios_1.default.create({
    httpAgent,
});
axios_retry_1.default(http, {
    retries: 0,
    retryCondition: retry_1.isAbortedOrNetworkErrorOrRouterTimeout,
    retryDelay: axios_retry_1.exponentialDelay,
    shouldResetTimeout: true,
});
const paramsSerializer = (params) => {
    return qs_1.stringify(params, { arrayFormat: 'repeat' });
};
exports.defaultsMiddleware = (baseURL, headers, params, timeout, retries, verbose) => {
    const countByMetric = {};
    return async (ctx, next) => {
        ctx.config = Object.assign({ 'axios-retry': retries ? { retries } : undefined, baseURL, maxRedirects: 0, timeout, validateStatus: status => (status >= 200 && status < 300), verbose }, ctx.config, { headers: Object.assign({}, headers, ctx.config.headers), params: Object.assign({}, params, ctx.config.params), paramsSerializer });
        if (ctx.config.verbose && ctx.config.metric) {
            const current = countByMetric[ctx.config.metric];
            countByMetric[ctx.config.metric] = (current || 0) + 1;
            ctx.config.count = countByMetric[ctx.config.metric];
            ctx.config.label = `${ctx.config.metric}#${ctx.config.count}`;
        }
        await next();
    };
};
exports.requestMiddleware = (limit) => async (ctx, next) => {
    const makeRequest = () => {
        let start;
        if (ctx.config.verbose && ctx.config.label) {
            start = process.hrtime();
            console.log(ctx.config.label, `start`);
        }
        return http.request(ctx.config).then((r) => {
            if (start) {
                const end = process.hrtime(start);
                const millis = time_1.hrToMillis(end);
                console.log(ctx.config.label, `millis=${millis} status=${r.status}`);
            }
            return r;
        }).catch((e) => {
            if (start) {
                const end = process.hrtime(start);
                const millis = time_1.hrToMillis(end);
                console.log(ctx.config.label, `millis=${millis} code=${e.code} ${e.response ? `status=${e.response.status}` : ''}`);
            }
            throw e;
        });
    };
    ctx.response = await (limit ? limit(makeRequest) : makeRequest());
};
function countPerOrigin(obj) {
    try {
        return ramda_1.mapObjIndexed(val => val.length, obj);
    }
    catch (_) {
        return {};
    }
}
function httpAgentStats() {
    const socketsPerOrigin = countPerOrigin(httpAgent.sockets);
    const sockets = ramda_1.sum(ramda_1.values(socketsPerOrigin));
    const freeSocketsPerOrigin = countPerOrigin(httpAgent.freeSockets);
    const freeSockets = ramda_1.sum(ramda_1.values(freeSocketsPerOrigin));
    const pendingRequestsPerOrigin = countPerOrigin(httpAgent.requests);
    const pendingRequests = ramda_1.sum(ramda_1.values(pendingRequestsPerOrigin));
    return {
        freeSockets,
        freeSocketsPerOrigin,
        pendingRequests,
        pendingRequestsPerOrigin,
        sockets,
        socketsPerOrigin,
    };
}
exports.httpAgentStats = httpAgentStats;
